{- Chapter 13. Free Monoids ------------------------------------------------------}

module Section203 where
open import Data.List using (List; _++_; []; [_]; _‚à∑_)
open import Data.List.Properties using (++-assoc; ++-identity ≥)
open import Data.Nat using (‚Ñï; _+_; _*_)
open import Data.Nat.Properties using (+-assoc; +-identity ≥)
open import Relation.Binary.PropositionalEquality using (_‚â°_; refl)

{- Monoids are an important concept in both category theory and in programming.
Categories correspond to strongly typed languages, monoids to untyped languages.
That's because in a monoid you can compose any two arrows, just as in an untyped
language you can compose any two functions (of course, you may end up with a
runtime error when you execute your program).

We've seen that a monoid may be described as a category with a single object,
where all logic is encoded in the rules of morphism composition.  This categorical
model is fully equivalent to the more traditional set-theoretical definition of a
monoid, where we "multiply" two elements of a set to get a third element.  This
process of "multiplication" can be further dissected into first forming a pair of
elements and then identifying this pair with an existing element---their
"product."

-- CONSTRUCTION OF THE FREE MONOID --

What happens when we forgo the second part of multiplication---the identification
of pairs with existing elements?  We can, for instance, start with an arbitrary
set, form all possible pairs of elements, and call them new elements.  Then we'll
pair these new elements with all possible elements, and so on. This is a chain
reaction---we'll keep adding new elements forever.  The result, an infinite set,
will be *almost* a monoid.  But a monoid also needs a unit element and the law of
associativity.  No problem, we can add a special unit element and identify some of
the pairs---just enough to support the unit and associativity laws.

Let's see how this works in a simple example.  Start with a set {a, b} of two
elements.  call them the generators of the free monoid.  Add a special element e
to serve as the unit.  Next, add all pairs of elements and call them "products."
The product of a and b will be the pair (a, b).  The product of b and a will be
the pair (b, a), the product of a with a will be (a, a), the product of b with b
will be (b, b).  We can also form pairs with e, like (a, e), (e, b), etc., but
we'll identify them with a, b, etc.  So in this round we'll only add (a, a),
(a, b), (b, a) and (b, b), and end up with the set

     {e, a, b, (a, a), (a, b), (b, a), (b, b)}.

In the next round we'll keep adding elements like: (a, (a, b)), ((a, b), a), etc.
At this point we'll have to make sure that associativity holds, so we'll identify
(a, (b, a)) with ((a, b), a), etc.  In other words, we won't be needing internal
parentheses.

You can guess what the final result of this process will be: we'll create all
possible lists of as and bs.  In fact, if we represent e as an empty list, we can
see that our "multiplication" is nothing but list concatenation.

This kind of construction, in which you keep generating all possible combinations
of elements, and perform the minimum number of identifications---just enough to
uphold the laws---is called a free construction.  What we have just done is to
construct a *free monoid* from the set {a, b} of generators.                     -}

{- Section 13.1. Free Monoid in Haskell ------------------------------------------}
{- A two-element set in Haskell is equivalent to the type Bool, and the free
monoid generated by this set is equivalent to the type [Bool] (list of Bool).  (I
am deliberately ignoring problems with infinite lists.)

A monoid in Agda is defined by the type class                        [snippet01] -}

module _ (A : Set) where

  record Monoid : Set where
    field
      mempty   : A
      mappend  : A ‚Üí A ‚Üí A
      leftId   : ‚àÄ a ‚Üí mappend mempty a ‚â° a
      rightId  : ‚àÄ a ‚Üí mappend a mempty ‚â° a
      assoc    : ‚àÄ a b c ‚Üí mappend (mappend a b) c ‚â° mappend a (mappend b c)
{-                                                                   [snippet02] -}
instance
  listMonoid : ‚àÄ {A : Set} ‚Üí Monoid (List A)
  listMonoid = record
                { mempty = []
                ; mappend = _++_
                ; leftId = Œª _ ‚Üí refl
                ; rightId = ++-identity ≥
                ; assoc = ++-assoc }

_ : 2 * 3 ‚â° 6
_ = refl
_ : [ 2 ] ++ [ 3 ] ‚â° 2 ‚à∑ 3 ‚à∑ [] -- not the same as [6]
_ = refl

module _ {A : Set}{B : Set}{ùî∏ : Monoid A}{ùîπ : Monoid B} where
  open Monoid ùî∏ renaming (mappend to _*·¥¨_)
  open Monoid ùîπ renaming (mappend to _*·¥Æ_)

  hom : (A ‚Üí B) ‚Üí Set
  hom h = ‚àÄ {a‚ÇÅ a‚ÇÇ : A} ‚Üí h (a‚ÇÅ *·¥¨ a‚ÇÇ) ‚â° h a‚ÇÅ *·¥Æ h a‚ÇÇ
